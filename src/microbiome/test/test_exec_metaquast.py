""" Module to test exec_metaquast member methods. This module contains unit tests for exec_metaquast.py. """

import os
import unittest
import shutil

from src import exec_metaquast

__author__ = "YiDing Fang"
__maintainer__ = "YiDing Fang"
__email__ = "yif017@eng.ucsd.edu"
__status__ = "prototype"

# input file contents
_TRIM_R1_FASTQ_STR = """"""
_TRIM_U_FASTQ_STR = """"""

_METAQUAST_PATH = '/usr/local/quast-4.1/metaquast.py'


class TestExecMetaQuast(unittest.TestCase):
    """ Unit test exec_metaquast methods """

    def setup_path(self):
        """ create strings corresponding to the temporary directories and files to be used in unit tests """

        # input directory
        _TEST_DATA = 'test_data'

        # sample meta contigs found with quast install
        _META_FA_1_STR = 'meta_contigs_1.fasta'
        _META_FA_2_STR = 'meta_contigs_2.fasta'

        # temporary directories to be used
        _UNITTEST_DIR_STR = 'metaquast_unittest_temp_dir'
        _OUTPUT_DIR_STR = 'output'
        _INPUT_DIR_STR = 'input'

        _COMBINED_REFERENCE = 'combined_reference'
        _KRONA_CHARTS = 'krona_charts'
        _QUAST_DOWNLOADED_REFERENCES = 'quast_downloaded_references'
        _SUMMARY = 'summary'
        _ICARUS_VIEWERS = 'icarus_viewers'
        _NOT_ALIGNED = 'not_aligned'
        _RUNS_PER_REFERENCE = 'runs_per_reference'

        # log file for the pipeline
        _PIPELINE_LOG = 'pipeline.log'
        _METAQUAST_LOG = 'metaquast.log'

        # reports generated by function call
        _REPORT_HTML = 'report.html'
        _ICARUS_HTML = 'icarus.html'

        # full file paths
        self.metaquast_path = _METAQUAST_PATH
        self.unittest_dir = _UNITTEST_DIR_STR
        self.output_dir = os.path.join(_UNITTEST_DIR_STR, _OUTPUT_DIR_STR)
        self.input_dir = os.path.join(_UNITTEST_DIR_STR, _INPUT_DIR_STR)

        metaquast_dir, executable = os.path.split(_METAQUAST_PATH)
        test_data_dir = os.path.join(metaquast_dir, _TEST_DATA)
        self.meta_fa_1 = os.path.join(test_data_dir, _META_FA_1_STR)
        self.meta_fa_2 = os.path.join(test_data_dir, _META_FA_2_STR)

        self.combined_ref = os.path.join(self.output_dir, _COMBINED_REFERENCE)
        self.krona_charts = os.path.join(self.output_dir, _KRONA_CHARTS)
        self.quast_download_ref = os.path.join(self.output_dir, _QUAST_DOWNLOADED_REFERENCES)
        self.summary = os.path.join(self.output_dir, _SUMMARY)
        self.icarus_viewers = os.path.join(self.output_dir, _ICARUS_VIEWERS)
        self.not_aligned = os.path.join(self.output_dir, _NOT_ALIGNED)
        self.runs_per_reference = os.path.join(self.output_dir, _RUNS_PER_REFERENCE)

        self.pipe_log = os.path.join(self.output_dir, _PIPELINE_LOG)
        self.metaquast_log = os.path.join(self.output_dir, _METAQUAST_LOG)

        self.report_html = os.path.join(self.output_dir, _REPORT_HTML)
        self.icarus_html = os.path.join(self.output_dir, _ICARUS_HTML)

    # TODO: Check if the OSError is thrown in case we remove something improperly
    def clear_dir(self, target_dir):
        """ Selectively remove files in a directory using the given file extension names """

        # output file extensions
        _OUT_EXT = ['.fq', '.fastq', '.fa', '.fasta', '.txt', '.lib', '.bin', '.info', '.lib_info',
                    '.log', '.tex', '.txt', '.tsv', '.pdf']

        if os.path.exists(target_dir):
            # remove all the files in the intermediate contigs directory
            filelist = [f for f in os.listdir(target_dir) if f.endswith(tuple(_OUT_EXT))]
            for f in filelist:
                f_path = os.path.join(target_dir, f)
                os.remove(f_path)

    def setUp(self):
        """ create temporary files and directories to be used in the unit tests """

        self.setup_path()
        # create a sample directory to use for input and output
        if not os.path.exists(self.unittest_dir):
            os.makedirs(self.unittest_dir)
            print("created directory: {0}".format(self.unittest_dir))
        else:
            print("There exists conflicting directory named: {0}".format(self.unittest_dir))

        temp_dir_list = [self.input_dir, self.output_dir]
        for temp_dir in temp_dir_list:
            # create the appropriate directories
            if not os.path.exists(temp_dir):
                os.makedirs(temp_dir)
                print("created directory: {0}".format(temp_dir))
            else:
                print("There exists conflicting directory named: {0}".format(temp_dir))

        input_test_files = [self.meta_fa_1, self.meta_fa_2]
        for test_file in input_test_files:
            if not os.path.isfile(test_file):
                raise ValueError(
                    "Input file {0} does not exist. Please check metaquast/test_Data directory for sample test files".format
                    (test_file))

    def tearDown(self):
        """delete temporary files and directories generated by setUp method and megahit subprocess calls"""

        if os.path.exists(self.unittest_dir):
            if os.path.exists(self.input_dir):
                self.clear_dir(self.input_dir)
                os.rmdir(self.input_dir)
                print("removed directory: {0}".format(self.input_dir))
            if os.path.exists(self.output_dir):
                expected_file_list = [self.report_html, self.icarus_html, self.metaquast_log, self.pipe_log]
                for out_file in expected_file_list:
                    if os.path.exists(out_file):
                        os.remove(out_file)
                        print("removed file: {0}".format(out_file))
                expected_sub_dir_list = [self.combined_ref, self.krona_charts, self.quast_download_ref, self.summary,
                                         self.icarus_viewers, self.not_aligned, self.runs_per_reference]
                for sub_dir in expected_sub_dir_list:
                    if os.path.exists(sub_dir):
                        shutil.rmtree(sub_dir)
                        print("removed directory: {0}".format(sub_dir))
                os.rmdir(self.output_dir)
                print("removed directory: {0}".format(self.output_dir))
            # remove the unittest directory
            os.rmdir(self.unittest_dir)
            print("removed directory: {0}".format(self.unittest_dir))
        else:
            print("The unittest directory {0} does not exist".format(self.unittest_dir))

    # region form_metaquast_cmd_list tests
    def test_form_metaquast_cmd_list_no_args(self):
        """ test that the form_metaquast_cmd_list correctly raises a Value Error when invalid empty string is used in
        place of required input """

        # arguments to be formatted
        null_metaquast_path = ''
        # non-existent fasta files
        null_fa = []
        # option for output directory omitted
        null_outdir = None

        # catch a value exception when strings are empty
        with self.assertRaises(ValueError):
            exec_metaquast.form_metaquast_cmd_list(null_metaquast_path, null_outdir, null_fa)

    def test_form_metaquast_cmd_list_invalid_num_args(self):
        """ test that form_metaquast_cmd_list correctly raises a Type Error when the wrong number of input
        arguments is used """

        with self.assertRaises(TypeError):
            exec_metaquast.form_metaquast_cmd_list(self.metaquast_path)

    def test_form_metaquast_cmd_list(self):
        """ test shall check that form_metaquast_cmd_list correctly generates a metaquast command list when passed
        valid arguments for the metaquast file path, output directory, and contigs """

        # input file names

        input_contigs = [self.meta_fa_1, self.meta_fa_2]

        cmd_no_outdir_list = ['python2', '/usr/local/quast-4.1/metaquast.py',
                              '/usr/local/quast-4.1/test_data/meta_contigs_1.fasta',
                              '/usr/local/quast-4.1/test_data/meta_contigs_2.fasta',
                              '-o', 'metaquast_unittest_temp_dir/output']

        self.assertEqual(cmd_no_outdir_list,
                         exec_metaquast.form_metaquast_cmd_list(self.metaquast_path, self.output_dir, input_contigs))
    # endregion

    # region run_metaquast_cmd_list tests
    def test_run_metaquast_cmd_list_no_args(self):
        """ test that run_metaquast correctly raises a Value Error when invalid empty string is used in place of
        required input """

        # arguments to be formatted
        null_metaquast_path = ''
        # non-existent fasta files
        null_fa = []
        # option for output directory omitted
        null_outdir = None

        # catch a value exception when strings are empty
        with self.assertRaises(ValueError):
            exec_metaquast.run_metaquast(null_metaquast_path, null_outdir, null_fa)

    def test_run_metaquast_cmd_list_invalid_num_args(self):
        """ test that run_megahit correctly raises a Type Error when an invalid number of arguments is used in place of
         required input """

        # program path
        with self.assertRaises(TypeError):
            exec_metaquast.run_metaquast(self.metaquast_path)

    def test_run_metaquast_good_stdout(self):
        """ test that quast subproccess call reports successful completion message to stdout when run_metaquast
        is passed valid arguments for the metaquast file path, output directory, and input contigs """

        _SUCCESSFUL_COMPLETION = 'MetaQUAST finished.'

        # input file names
        input_contigs = [self.meta_fa_1, self.meta_fa_2]
        stdout, _ = exec_metaquast.run_metaquast(self.metaquast_path, self.output_dir, input_contigs)

        # print(stdout)
        self.assertNotEqual(stdout.find(_SUCCESSFUL_COMPLETION), -1)

    def test_run_metaquast_metaquast_log_generated(self):
        """ test that quast subproccess call generates metquast log file when run_metaquast is passed valid arguments
        for the metaquast file path, output directory, and input contigs indicating that a process has been run and that
        input files were modified """

        # input file names
        input_contigs = [self.meta_fa_1, self.meta_fa_2]
        exec_metaquast.run_metaquast(self.metaquast_path, self.output_dir, input_contigs)

        self.assertTrue(os.stat(self.metaquast_log).st_size>0)

    def test_run_metaquast_report_generated(self):
        """ test that quast subproccess call generates metaquast report file when run_metaquast
        is passed valid arguments for the metaquast file path, output directory, and input contigs indicating completion
        of the metaquast process """

        # input file names
        input_contigs = [self.meta_fa_1, self.meta_fa_2]
        exec_metaquast.run_metaquast(self.metaquast_path, self.output_dir, input_contigs)

        self.assertTrue(os.stat(self.report_html).st_size>0)

    def test_run_metaquast_icarus_generated(self):
        """ test that quast subproccess call generates icarus html report when run_metaquast is passed valid arguments
        for the metaquast file path, output directory, and input contigs indicating completion of the
        metaquast process """

        # input file names
        input_contigs = [self.meta_fa_1, self.meta_fa_2]
        exec_metaquast.run_metaquast(self.metaquast_path, self.output_dir, input_contigs)

        self.assertTrue(os.stat(self.icarus_html).st_size > 0)

    def test_run_metaquast_icarus_charts_generated(self):
        """ test that quast subproccess call generates icarus charts when run_metaquast is passed valid arguments for
        the metaquast file path, output directory, and input contigs indicating completion of the metaquast process """

        # input file names
        input_contigs = [self.meta_fa_1, self.meta_fa_2]
        exec_metaquast.run_metaquast(self.metaquast_path, self.output_dir, input_contigs)

        # check to see that icarus viewer files exist
        icarus_chart_list = os.listdir(self.icarus_viewers)
        self.assertTrue(len(icarus_chart_list) > 0)

    def test_run_metaquast_krona_charts_generated(self):
        """ test that quast subproccess call generates krona charts when run_metaquast is passed valid arguments for
        the metaquast file path, output directory, and input contigs indicating completion of the metaquast process """

        # input file names
        input_contigs = [self.meta_fa_1, self.meta_fa_2]
        exec_metaquast.run_metaquast(self.metaquast_path, self.output_dir, input_contigs)

        # check to see that the krona charts exist
        krona_chart_list = os.listdir(self.krona_charts)
        self.assertTrue(len(krona_chart_list) > 0)

    def test_run_metaquast_not_aligned_files_generated(self):
        """ test that quast subproccess call generates directory containing reports without alignment when
        run_metaquast is passed valid arguments for the metaquast file path, output directory, and input contigs
        indicating completion of the metaquast process """

        # input file names
        input_contigs = [self.meta_fa_1, self.meta_fa_2]
        exec_metaquast.run_metaquast(self.metaquast_path, self.output_dir, input_contigs)

        # check that the not-aligned directory contains files
        not_aligned_file_list = os.listdir(self.not_aligned)
        self.assertTrue(len(not_aligned_file_list) > 0)

    def test_run_metaquast_txt_summary_generated(self):
        """ test that quast subproccess call generates directory containing text based summary reports when
        run_metaquast is passed valid arguments for the metaquast file path, output directory, and input contigs
        indicating completion of the metaquast process """

        _TEXT_DIR = "TXT"

        # input file names
        input_contigs = [self.meta_fa_1, self.meta_fa_2]
        exec_metaquast.run_metaquast(self.metaquast_path, self.output_dir, input_contigs)

        # check that txt output is available for future pipeline summary
        text_summary_dir = os.path.join(self.summary, _TEXT_DIR)
        txt_summary_list = os.listdir(text_summary_dir)

        self.assertTrue(len(txt_summary_list) > 0)

    # TODO: continue to check that the other files are generated
    # TODO: create tests that fail test cases outlined here
